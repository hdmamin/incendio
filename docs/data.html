---

title: Data

keywords: fastai
sidebar: home_sidebar

summary: "Tools to help construct datasets, which may be related to loading, processing, or encoding data."
description: "Tools to help construct datasets, which may be related to loading, processing, or encoding data."
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/07_data.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> autoreload
<span class="o">%</span><span class="k">autoreload</span> 2
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Only needed for testing.</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="k">import</span> <span class="n">DataLoader</span>

<span class="kn">from</span> <span class="nn">htools</span> <span class="k">import</span> <span class="n">eprint</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="probabilistic_hash_item" class="doc_header"><code>probabilistic_hash_item</code><a href="https://github.com/hdmamin/incendio/tree/master/incendio/data.py#L24" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>probabilistic_hash_item</code>(<strong><code>x</code></strong>, <strong><code>n_buckets</code></strong>, <strong><code>mode</code></strong>=<em><code>'int'</code></em>, <strong><code>n_hashes</code></strong>=<em><code>3</code></em>)</p>
</blockquote>

<pre><code>Slightly hacky way to probabilistically hash an integer by
first converting it to a string.

Parameters
----------
x: int
    The integer or string to hash.
n_buckets: int
    The number of buckets that items will be mapped to. Typically
    this would occur outside the hashing function, but since
    the intended use case is so narrow here it makes sense to me
    to include it here.
mode: type
    The type of input you want to hash. This is user-provided to prevent
    accidents where we pass in a different item than intended and hash
    the wrong thing. One of (int, str). When using this inside a
    BloomEmbedding layer, this must be `int` because there are no
    string tensors. When used inside a dataset or as a one-time
    pre-processing step, you can choose either as long as you
    pass in the appropriate inputs.
n_hashes: int
    The number of times to hash x, each time with a different seed.

Returns
-------
list[int]: A list of integers with length `n_hashes`, where each integer
    is in [0, n_buckets).</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="probabilistic_hash_tensor" class="doc_header"><code>probabilistic_hash_tensor</code><a href="https://github.com/hdmamin/incendio/tree/master/incendio/data.py#L60" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>probabilistic_hash_tensor</code>(<strong><code>x_r2</code></strong>, <strong><code>n_buckets</code></strong>, <strong><code>n_hashes</code></strong>=<em><code>3</code></em>, <strong><code>pad_idx</code></strong>=<em><code>0</code></em>)</p>
</blockquote>

<pre><code>Hash a rank 2 LongTensor.

Parameters
----------
x_r2: torch.LongTensor
    Rank 2 tensor of integers. Shape: (bs, seq_len)
n_buckets: int
    Number of buckets to hash items into (i.e. the number of
    rows in the embedding matrix). Typically a moderately large
    prime number, like 251 or 997.
n_hashes: int
    Number of hashes to take for each input index. This determines
    the number of rows of the embedding matrix that will be summed
    to get the representation for each word. Typically 2-5.
pad_idx: int or None
    If you want to pad sequences with vectors of zeros, pass in an
    integer (same as the `padding_idx` argument to nn.Embedding).
    If None, no padding index will be used. The sequences must be
    padded before passing them into this function.

Returns
-------
torch.LongTensor: Tensor of indices where each row corresponds
    to one of the input indices. Shape: (bs, seq_len, n_hashes)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sents</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;I walked to the store so I hope it is not closed.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;The theater is closed today and the sky is grey.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;His dog is brown while hers is grey.&#39;</span>
<span class="p">]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentences</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w2i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_w2i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_len</span> <span class="o">=</span> <span class="n">seq_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">make_w2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok_rows</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> 
                <span class="nb">enumerate</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">tok_rows</span><span class="p">))</span><span class="o">.</span><span class="n">most_common</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)}</span>
    
    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok_rows</span><span class="p">):</span>
        <span class="n">enc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tok_rows</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_len</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tok_rows</span><span class="p">):</span>
            <span class="n">trunc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w2i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_len</span><span class="p">]]</span>
            <span class="n">enc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">trunc</span><span class="p">)]</span> <span class="o">=</span> <span class="n">trunc</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">enc</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We construct a toy dataset with a vocabulary of size 23. In reality, you might wish to lowercase text or use a better tokenizer, but this is sufficient for the purposes of demonstration.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">sents</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">w2i</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>23</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dl</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dl</span><span class="p">))</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(tensor([[ 2,  5,  6,  3,  7,  8,  2,  9, 10,  1],
         [13, 14,  1, 15, 16, 17,  3, 18,  1,  4],
         [19, 20,  1, 21, 22, 23,  1,  4,  0,  0]]), tensor([0, 1, 1]))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([3, 10])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We hash each word index 4 times, as specified by the <code>n_hashes</code> parameter in <a href="/incendio/data#probabilistic_hash_tensor"><code>probabilistic_hash_tensor</code></a>. Notice that we only use 7 buckets, meaning the embedding matrix will have 7 rows rather than 23 (not counting a padding row).</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x_hashed</span> <span class="o">=</span> <span class="n">probabilistic_hash_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_buckets</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">n_hashes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x shape:&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x_hashed shape:&#39;</span><span class="p">,</span> <span class="n">x_hashed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>x shape: torch.Size([3, 10])
x_hashed shape: torch.Size([3, 10, 4])
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Below, each row of 4 numbers encodes a single word.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x_hashed</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([[[2, 0, 2, 2],
         [1, 6, 2, 4],
         [2, 0, 1, 4],
         [5, 2, 6, 5],
         [1, 5, 1, 3],
         [0, 4, 0, 0],
         [2, 0, 2, 2],
         [2, 4, 0, 2],
         [3, 4, 4, 6],
         [5, 0, 3, 6]],

        [[5, 4, 4, 2],
         [5, 3, 3, 1],
         [5, 0, 3, 6],
         [2, 1, 1, 1],
         [2, 4, 4, 4],
         [2, 4, 2, 6],
         [5, 2, 6, 5],
         [3, 5, 0, 0],
         [5, 0, 3, 6],
         [1, 5, 2, 6]],

        [[5, 5, 3, 4],
         [4, 5, 5, 1],
         [5, 0, 3, 6],
         [6, 2, 0, 6],
         [4, 2, 6, 1],
         [3, 6, 1, 6],
         [5, 0, 3, 6],
         [1, 5, 2, 6],
         [0, 0, 0, 0],
         [0, 0, 0, 0]]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>See how each word is mapped to a list of 4 indices.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">probabilistic_hash_item</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="mi">7</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>I [2, 0, 2, 2]
walked [1, 6, 2, 4]
to [2, 0, 1, 4]
the [5, 2, 6, 5]
store [1, 5, 1, 3]
so [0, 4, 0, 0]
I [2, 0, 2, 2]
hope [2, 4, 0, 2]
it [3, 4, 4, 6]
is [5, 0, 3, 6]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Notice that hashing the words directly is also possible, but the resulting hashes will be <strong>different</strong> than if hashing after encoding words as integers. This is fine as long as you are consistent.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sents</span><span class="p">]:</span>
    <span class="n">eprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">probabilistic_hash_item</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">row</span><span class="p">))))</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre> 0: (&#39;I&#39;, [0, 5, 5])
 1: (&#39;walked&#39;, [2, 5, 1])
 2: (&#39;to&#39;, [10, 4, 6])
 3: (&#39;the&#39;, [4, 1, 4])
 4: (&#39;store&#39;, [4, 6, 3])
 5: (&#39;so&#39;, [7, 8, 8])
 6: (&#39;I&#39;, [0, 5, 5])
 7: (&#39;hope&#39;, [1, 2, 7])
 8: (&#39;it&#39;, [3, 9, 0])
 9: (&#39;is&#39;, [3, 1, 3])
10: (&#39;not&#39;, [6, 10, 4])
11: (&#39;closed.&#39;, [3, 6, 10])

 0: (&#39;The&#39;, [1, 6, 9])
 1: (&#39;theater&#39;, [8, 10, 2])
 2: (&#39;is&#39;, [3, 1, 3])
 3: (&#39;closed&#39;, [5, 5, 0])
 4: (&#39;today&#39;, [3, 10, 8])
 5: (&#39;and&#39;, [7, 2, 4])
 6: (&#39;the&#39;, [4, 1, 4])
 7: (&#39;sky&#39;, [1, 2, 9])
 8: (&#39;is&#39;, [3, 1, 3])
 9: (&#39;grey.&#39;, [7, 6, 7])

 0: (&#39;His&#39;, [0, 10, 3])
 1: (&#39;dog&#39;, [8, 6, 6])
 2: (&#39;is&#39;, [3, 1, 3])
 3: (&#39;brown&#39;, [9, 8, 9])
 4: (&#39;while&#39;, [9, 2, 8])
 5: (&#39;hers&#39;, [0, 5, 4])
 6: (&#39;is&#39;, [3, 1, 3])
 7: (&#39;grey.&#39;, [7, 6, 7])

</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Below, we show that we can obtain unique representations for &gt;99.9% of words in a vocabulary of 30,000 words with a far smaller embedding matrix. The number of buckets is the number of rows in the embedding matrix.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">unique_combos</span><span class="p">(</span><span class="n">tups</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tups</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">hash_all_idx</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">n_buckets</span><span class="p">,</span> <span class="n">n_hashes</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">probabilistic_hash_item</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n_buckets</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_hashes</span><span class="p">)</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">)]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab_size</span> <span class="o">=</span> <span class="mi">30_000</span>
<span class="n">buckets2hashes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">127</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                  <span class="mi">251</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                  <span class="mi">997</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                  <span class="mi">5_003</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">buckets2hashes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">tups</span> <span class="o">=</span> <span class="n">hash_all_idx</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>  <span class="n">h</span><span class="p">)</span>
    <span class="n">unique</span> <span class="o">=</span> <span class="n">unique_combos</span><span class="p">(</span><span class="n">tups</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">Buckets:&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Hashes:&#39;</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Unique combos:&#39;</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span>
          <span class="s1">&#39;</span><span class="se">\n</span><span class="si">% u</span><span class="s1">nique:&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">unique</span><span class="o">/</span><span class="mi">30_000</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>

Buckets: 127 
Hashes: 5 
Unique combos: 29998 
% unique: 0.9999


Buckets: 251 
Hashes: 4 
Unique combos: 29996 
% unique: 0.9999


Buckets: 997 
Hashes: 3 
Unique combos: 29997 
% unique: 0.9999


Buckets: 5003 
Hashes: 2 
Unique combos: 29969 
% unique: 0.999
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Datasets">Datasets<a class="anchor-link" href="#Datasets"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@auto_repr</span>
<span class="k">class</span> <span class="nc">LazyDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lazily load batches from an enormous dataframe that can&#39;t fit into </span>
<span class="sd">    memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_path</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1_000</span><span class="p">,</span> 
                 <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;neg&#39;</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_path: str</span>
<span class="sd">            File path of dataframe to load.</span>
<span class="sd">        length: int</span>
<span class="sd">            Number of rows of data to use. This is required so that we don&#39;t </span>
<span class="sd">            have to go through the whole file and count the number of lines,</span>
<span class="sd">            which can be enormous with a big dataset. It also makes it easy to</span>
<span class="sd">            work with a subset (the data should already be shuffled, so </span>
<span class="sd">            choosing the top n rows is fine).</span>
<span class="sd">        shuffle: bool</span>
<span class="sd">            If True, shuffle the data in each chunk. Note that if batch size</span>
<span class="sd">            is close to chunk size, this will have minimal effect. If possible,</span>
<span class="sd">            the training set should therefore load as large a chunk as </span>
<span class="sd">            possible if we want to shuffle the data. Shuffling is unnecessary </span>
<span class="sd">            for the validation set.</span>
<span class="sd">        chunksize: int</span>
<span class="sd">            Number of rows of df to load at a time. This should usually </span>
<span class="sd">            be significantly larger than the batch size in order to retain</span>
<span class="sd">            some randomness in the batches.</span>
<span class="sd">        c: int</span>
<span class="sd">            Number of classes. Used if training with FastAI.</span>
<span class="sd">        classes: iterable</span>
<span class="sd">            List of tuple of class names. Used if training with FastAI.</span>
<span class="sd">        kwargs: any</span>
<span class="sd">            Additional keyword arguments to pass to `read_csv`, eg. </span>
<span class="sd">            compression=&#39;gzip&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">chunksize</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Total # of rows &lt; 1 full chunk. LazyDataset may &#39;</span>
                          <span class="s1">&#39;not be necessary.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">chunksize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_path</span> <span class="o">=</span> <span class="n">df_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        
        <span class="c1"># Additional attributes required by FastAI. </span>
        <span class="c1"># c: Number of classes in model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
    
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Because not all indices are loaded at once, we must do shuffling</span>
<span class="sd">        in the dataset rather than the dataloader (e.g. if the loader randomly</span>
<span class="sd">        samples index 5000 but we have indices 0-500 loaded, it will be</span>
<span class="sd">        unavailable).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx: int</span>
<span class="sd">            Retrieve item i in dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[np.array]: x array, y array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load next chunk of data if necessary. Must specify nrows, otherwise</span>
        <span class="c1"># we will chunk through the whole file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">get_chunk</span><span class="p">()</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">StopIteration</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">,</span>
                                          <span class="n">chunksize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunksize</span><span class="p">,</span>
                                          <span class="n">nrows</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                          <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">df_kwargs</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span><span class="p">)</span>
            
        <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_idx</span><span class="o">.</span><span class="n">popleft</span><span class="p">()]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="File-Handling">File Handling<a class="anchor-link" href="#File-Handling"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BotoUploader" class="doc_header"><code>class</code> <code>BotoUploader</code><a href="https://github.com/hdmamin/incendio/tree/master/incendio/data.py#L94" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BotoUploader</code>(<strong><code>bucket</code></strong>, <strong><code>verbose</code></strong>=<em><code>True</code></em>)</p>
</blockquote>

<pre><code>Uploads files to S3. Built as a public alternative to Accio. Note to
self: the interfaces are not identical so be careful to know which you're
using.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">up</span> <span class="o">=</span> <span class="n">BotoUploader</span><span class="p">(</span><span class="s1">&#39;gg-datascience&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ft</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">_convert_local_path</span><span class="p">(</span><span class="s1">&#39;data/v1/history.csv&#39;</span><span class="p">)</span>
<span class="n">tt</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">_convert_local_path</span><span class="p">(</span><span class="s1">&#39;data/v1/history.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;hmamin&#39;</span><span class="p">)</span>
<span class="n">tf</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">_convert_local_path</span><span class="p">(</span><span class="s1">&#39;data/v1/history.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;hmamin&#39;</span><span class="p">,</span> <span class="n">retain_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ff</span> <span class="o">=</span> <span class="n">up</span><span class="o">.</span><span class="n">_convert_local_path</span><span class="p">(</span><span class="s1">&#39;data/v1/history.csv&#39;</span><span class="p">,</span> <span class="n">retain_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No S3 prefix, Yes retain file tree:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">ft</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Yes S3 prefix, Yes retain file tree:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">tt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Yes S3 prefix, No retain file tree:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">tf</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No S3 prefix, No retain file tree:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">ff</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>No S3 prefix, Yes retain file tree:
data/v1/history.csv

Yes S3 prefix, Yes retain file tree:
hmamin/data/v1/history.csv

Yes S3 prefix, No retain file tree:
hmamin/history.csv

No S3 prefix, No retain file tree:
history.csv
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

